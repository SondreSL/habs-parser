-- COMMENTS
-----------
comment "//" ;
comment "/*" "*/" ;


-- LITERALS
-----------
LNull.   Literal ::= "null" ;
LThis.   Literal ::= "this" ;
LStr.    Literal ::= String ;
LInt.    Literal ::= Integer ;


-- IDENTIFIER TOKENS
--------------------
position token U (upper (letter | digit | '_')*) ;
position token L (lower (letter | digit | '_')*) ;


-- MAYBE-QUALIFIED IDENTIFIERS
------------------------------

-- upper
U_. QU ::= U ;
QU. QU ::= U "." QU ;
-- lower
L_. QL ::= L ;
QL. QL ::= U "." QL ;
-- any
LA. QA ::= L ;
UA. QA ::= U ;
QA. QA ::= U "." QA;

separator nonempty U "," ; -- for <Typevar1,..>
separator nonempty QU "," ; -- for list of types/constructors 
separator nonempty QA "," ; -- for imports/exports


-- TYPES
--------
TSimple. T ::= QU ;
TGen. T    ::= QU "<" [T] ">" ;
TInfer. T  ::= "_" ;  -- habs-only: for type inference
separator nonempty T "," ;


-- FORMAL PARAMETERS
--------------------
Par. Param ::= T L ;
separator Param "," ;  -- for list of formal parameters


-- ENTRY PROGRAM
----------------
entrypoints Program ;
Program. Program ::= [Module] ; -- multiple modules inside a single file


-- MODULES 
----------
Module. Module ::= "module" QU ";" [Export] [Import] [AnnDecl] MaybeBlock ;
separator Module "";


-- EXPORTS
----------
StarExport. Export     ::= "export" "*" ;
StarFromExport. Export ::= "export" "*" "from" QU ;
AnyExport. Export      ::= "export" [QA] ;
AnyFromExport. Export  ::= "export" [QA] "from" QU ; -- note to self: should be unqualified, but for parser issues do the check it at codegen
terminator Export ";" ;


-- IMPORTS
----------
StarFromImport. Import ::= IsForeign "*" "from" QU ;
AnyImport. Import      ::= IsForeign [QA] ;
AnyFromImport. Import  ::= IsForeign [QA] "from" QU ; -- note to self: should be unqualified, but for parser issues do the check it at codegen
terminator Import ";" ;

Native. IsForeign  ::= "import" ;
Foreign. IsForeign ::= "fimport" ; -- habs-only: is used to FFI to Haskell libraries


-- DECLARATIONS 
---------------


-- ADT DECLARATIONS
-------------------
TypeDecl. Decl      ::= "type" U "=" T ";" ;
TypeParDecl. Decl   ::= "type" U "<" [U] ">" "=" T ";" ;
ExceptionDecl. Decl ::= "exception" ConstrIdent ";" ;
DataDecl. Decl      ::= "data" U "=" [ConstrIdent] ";" ;
DataParDecl. Decl   ::= "data" U "<" [U] ">" "=" [ConstrIdent] ";" ;

separator nonempty ConstrIdent "|" ;
SinglConstrIdent. ConstrIdent ::= U ;
ParamConstrIdent. ConstrIdent ::= U "(" [ConstrType] ")" ;

separator ConstrType "," ;
EmptyConstrType. ConstrType  ::= T ;
RecordConstrType. ConstrType ::= T L ;


-- FUNCTION DECLARATIONS
------------------------
FunDecl.  Decl   ::= "def" T L "(" [Param] ")" "=" FunBody ";" ;
FunParDecl. Decl ::= "def" T L "<" [U] ">" "(" [Param] ")" "=" FunBody ";" ;
BuiltinFunBody. FunBody ::= "builtin" ;
NormalFunBody. FunBody  ::= PureExp ;

-- INTERFACE DECLARATIONS
-------------------------
InterfDecl. Decl  ::= "interface" U "{" [MethSignat] "}" ;
ExtendsDecl. Decl ::= "interface" U "extends" [QU] "{" [MethSignat] "}" ;

terminator MethSignat ";" ;
MethSignat. MethSignat ::= [Ann] T L "(" [Param] ")" ;


-- CLASS DECLARATIONS
---------------------
ClassDecl. Decl            ::= "class" U "{" [ClassBody] MaybeBlock [ClassBody] "}" ;
ClassParamDecl. Decl       ::= "class" U "(" [Param] ")" "{" [ClassBody] MaybeBlock [ClassBody]  "}" ;
ClassImplements. Decl      ::= "class" U "implements" [QU] "{" [ClassBody] MaybeBlock [ClassBody]  "}" ;
ClassParamImplements. Decl ::= "class" U "(" [Param] ")" "implements" [QU]  "{" [ClassBody] MaybeBlock [ClassBody]  "}" ;

separator ClassBody "" ;
FieldClassBody. ClassBody       ::= T L ";" ;
FieldAssignClassBody. ClassBody ::= T L "=" PureExp ";" ;
MethClassBody. ClassBody        ::= T L "(" [Param] ")" "{" [AnnStm] "}" ; -- braces are required

-- STATEMENTS
--------------
SExp.    Stm   ::= Exp ";" ; -- standalone expression
SSkip.    Stm  ::= "skip" ";" ;
SSuspend. Stm  ::= "suspend" ";" ;
SReturn.  Stm  ::= "return" Exp ";" ;
SAssert.  Stm  ::= "assert" PureExp ";" ;
SPrint. Stm    ::= "println" PureExp ";" ;
SAwait.  Stm   ::= "await" AwaitGuard ";" ;

SAss.    Stm   ::= L "=" Exp ";" ;
SFieldAss. Stm ::= "this" "." L "=" Exp ";" ;
SDec.    Stm   ::= T L ";" ;
SDecAss. Stm   ::= T L "=" Exp ";" ;

SWhile.  Stm   ::= "while" "(" PureExp ")" AnnStm ;
SIf.     Stm   ::= "if" "(" PureExp ")" Stm ; -- annstm here makes rr conflict
SIfElse. Stm   ::= "if" "(" PureExp ")" Stm "else" Stm ; -- annstm here makes rr conflict

SBlock.  Stm   ::= "{" [AnnStm] "}" ;

-- AWAIT GUARDS
---------------
ExpGuard. AwaitGuard      ::= PureExp ;
FutFieldGuard. AwaitGuard ::= "this" "." L "?" ;
FutGuard. AwaitGuard      ::= L "?" ;
AndGuard. AwaitGuard      ::= AwaitGuard "&" AwaitGuard ;

-- EXPRESSIONS
--------------
ExpP. Exp ::= PureExp ;
ExpE. Exp ::= EffExp ;

-- PURE EXPRESSIONS
-------------------
separator PureExp "," ;  -- for passing arguments to function/method calls
EOr.     PureExp         ::= PureExp "||" PureExp1 ;
EAnd.    PureExp1        ::= PureExp1 "&&" PureExp2 ;
EEq.     PureExp2        ::= PureExp2 "==" PureExp3 ;
ENeq.    PureExp2        ::= PureExp2 "!=" PureExp3 ;
ELt.     PureExp3        ::= PureExp3 "<" PureExp4 ;
ELe.     PureExp3        ::= PureExp3 "<=" PureExp4 ;
EGt.     PureExp3        ::= PureExp3 ">" PureExp4 ;
EGe.     PureExp3        ::= PureExp3 ">=" PureExp4 ;
EAdd.    PureExp4        ::= PureExp4 "+" PureExp5 ;
ESub.    PureExp4        ::= PureExp4 "-" PureExp5 ;
EMul.    PureExp5        ::= PureExp5 "*" PureExp6 ;
EDiv.    PureExp5        ::= PureExp5 "/" PureExp6 ;
EMod.    PureExp5        ::= PureExp5 "%" PureExp6 ;
ELogNeg. PureExp6        ::= "~" PureExp6 ;
EIntNeg. PureExp6        ::= "-" PureExp6 ;
EFunCall.    PureExp7    ::= QL "(" [PureExp] ")" ;
ENaryFunCall. PureExp7   ::= QL "[" [PureExp] "]" ;
EVar.    PureExp7        ::= L ;
EThis.   PureExp7        ::= "this" "." L ; 
ESinglConstr.   PureExp7 ::= QU ;
EParamConstr. PureExp7   ::= QU "(" [PureExp] ")" ;
ELit.    PureExp7        ::= Literal ;
coercions PureExp 7 ;

Let. PureExp          ::= "let" "(" Param ")" "=" PureExp "in" PureExp ;
If. PureExp           ::= "if" PureExp "then" PureExp "else" PureExp ;
Case. PureExp         ::= "case" PureExp "{" [CaseBranch] "}" ;

-- PATTERN MATCHING
-------------------
CaseBranc. CaseBranch ::= Pattern "=>" PureExp ;
terminator nonempty CaseBranch ";" ;

separator Pattern "," ;
PLit. Pattern         ::= Literal ;
PIdent. Pattern       ::= L ;
PSinglConstr. Pattern ::= QU ;
PParamConstr. Pattern ::= QU "(" [Pattern] ")" ;
PUnderscore. Pattern  ::= "_" ;


-- EFFECTFUL EXPRESSIONS
------------------------
New. EffExp               ::= "new" QU "(" [PureExp] ")" ;
NewLocal. EffExp          ::= "new" "local" QU "(" [PureExp] ")" ;
SyncMethCall. EffExp      ::= PureExp "." L "(" [PureExp] ")" ;
ThisSyncMethCall. EffExp  ::= "this" "." L "(" [PureExp] ")" ;
AsyncMethCall. EffExp     ::= PureExp "!" L "(" [PureExp] ")" ;
AwaitMethCall. EffExp     ::= "await" PureExp "!" L "(" [PureExp] ")" ;
ThisAsyncMethCall. EffExp ::= "this" "!" L "(" [PureExp] ")" ;
Get. EffExp               ::= PureExp "." "get" ;


-- ANNOTATIONS
--------------
Ann. Ann ::= "[" Ann_ "]";
separator Ann "" ;

AnnNoType.   Ann_ ::= PureExp  ;
AnnWithType. Ann_ ::= T ":" PureExp ;

AnnStm. AnnStm ::= [Ann] Stm;
terminator AnnStm "" ;

AnnDecl. AnnDecl ::= [Ann] Decl;
terminator AnnDecl "" ;

-- missing: classbody and type annotations
-- both yield many rr conflicts

-- EXTENSION, EXCEPTIONS
------------------------
SThrow. Stm           ::= "throw" PureExp ";" ;
STryCatchFinally. Stm ::= "try" AnnStm "catch" "{" [CatchBranch] "}" MaybeFinally ;

CatchBranc. CatchBranch ::= Pattern "=>" AnnStm ;
terminator CatchBranch "" ; -- can be empty, and does not have to be terminated by ";"

JustFinally. MaybeFinally ::= "finally" AnnStm ;
NoFinally. MaybeFinally   ::= ;


-- EXTENSION, PROMISES
------------------------
SGive. Stm ::= PureExp "." "pro_give" "(" PureExp ")" ";" ; -- habs-only
ProNew. EffExp ::= "pro_new" ; -- habs-only
ProTry. EffExp ::= PureExp "." "pro_try" ; -- habs-only

-- EXTENSION, DC
----------------
LThisDC.  Literal ::= "thisDC" ;

-- UTILS 
--------------
JustBlock. MaybeBlock ::= "{" [AnnStm] "}" ;
NoBlock.   MaybeBlock ::=  ;

